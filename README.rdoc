= Fancygrid
Fancygrid mades it easy to create and render tables for database records in rails.
== Features
* ActiveRecord and ActiveResource are supported
* Ajax data fetch
* Pagination
* Simple search with LIKE condition
* Complex search with 17 different conditions
* Column sorting
* View state caching
* Can be rendered anywhere, not restricted to the index action
* Column values may be attributes, methods, method chains or even custom blocks
* Custom templates for cell formatting

= Requirements
* jQuery >= 1.4.2
* jQuery-ui (required if column sorting is wanted)
* Rails 3
* Haml

= Installation
In your gemfile
    gem 'fancygrid'

Run
    bundle install

= Getting started

== Basic Setup
In any controller in any action you can define a fancygrid for a specific model.
A controller is the place where you define what data should be queried from
the model and what columns will be visible. Here is an example for a users table:
=== Example
    # UsersController
    def index

      fancygrid_for :users do |g|        
        # specify attributes to display  
        g.attributes :id, :username, :email 
        # specify the callback url for ajax loading
        g.ajax_url = users_path
        # finally call find and open a block
        g.find do |query|
          # 'query' is a magic wrapper object. you can call
          # any method that you would call after the 'find' method
          # on a record, like: 'where', 'order', 'select' etc.
          query.order "users.created_at DESC"
        end
      end
    end
  
In your View you have to render the fancygrid. Use the name that you have used
in your controller
=== Example
    # app/views/users/index.html.haml
    = fancygrid :users

== Static tables
If you dont want to have an ajax table, you can set the data directly without
providing a callback url. 
=== Example
    def index
      fancygrid_for :users do |g|
        # ...
        g.attributes :id, :username, :email 
        # don't set the ajax_url instead set the data directly
        g.records = User.find(:all)
        # no need to call the find method
      end
    end
   
== Table names and model names
Usually fancygrid takes the passed name and tries to resolve the models class
and its database table name. If you need to use a name that is different
from your models name, you can pass the models constant and its table name to fancygrid
=== Example
    def index
      fancygrid_for :user, Namespace::User, "users" do |g|
        # ...
      end
    end
    
= Values from attributes, methods and blocks
You are not limited to the models attributes to display in the fancygrid. 
You can use method names to display a models properties
=== Example
    def index  
      fancygrid_for :users do |g|
        # ...
        g.columns :full_name, :some_other_method
        # ...
      end
    end

You can also pass method chains
=== Example
    def index  
      fancygrid_for :users do |g|
        # ...
        g.columns "orders.count"
        # ...
      end
    end
    
You can even pass a proc
=== Example
    def index  
      fancygrid_for :users do |g|
        # ...
        g.columns :roles do |record|
          record.roles.map(&:name).join(", ")
        end
        # ...
      end
    end
    
For more complex output you have to format the cell value in the view or a formatter method

== Formatting columns within a haml block
In your view you can give a grid a block that should be used for rendering
=== Example
    = fancygrid :users do |leaf, record, value|
      - case leaf.name
      - when :actions
        = link_to "Show", user_path(record)
        = link_to "Edit", edit_user_path(record)
        
== belongs_to or has_one associations 
To display an associated data you have to build the nodes for that data and
specify the include option for the find method
=== Example
    def index  
      fancygrid_for :users do |g|
        # ...
        g.columns_for :contact do |contact|
          contact.attributes :first_name, :last_name
        end
        # ...
        g.find do |query|
          query.select :contact_id
          query.includes :contact
        end
      end
    end
    
If your association name is different from the models name pass the model 
constant into the columns_for method.
=== Example
    def index  
      fancygrid_for :users do |g|
        # ...
        g.columns_for(:invoice_address, Address) do |adr|
          adr.attributes :street, :zipcode, :city
        end
        # ...
        g.find do |query|
          query.select :invoice_address_id
          query.includes :invoice_address
        end
      end
    end
    
== has_many or has_and_belongs_to_many associations
Similar to the previous example you have to build the nodes for the associations
and specify the include option
=== Example
    def index  
      fancygrid_for :users do |g|
        # ...
        g.columns_for :roles do |roles|
          roles.attributes :name 
        end
        # ...
        g.find do |query|
          query.includes :roles
        end
      end
    end
    
However this would not work as expected. Its the same as calling <tt>user.roles.name</tt>
which would call <tt>name</tt> on a collection of roles.

Instead you should rather define a <tt>proc</tt> to return all role names or 
render that cell with custom code.
=== Example      
    def index  
      fancygrid_for :users do |g|
        # ...
        g.columns :roles  do |record|
          record.roles.map(&:name).join(", ")
        end
        # ...
      end
    end

== Caching the view state
To make your users life easier you can enable the view state caching. This way
the user can search for data, leave the site, come back and have his last
search back on screen. Here is an example of how to store the view in the users session:
=== Example
    def index
      fancygrid_for :users, :persist => true do |grid|
        # ...
      end
    end
   
= Copyright
Copyright (c) 2010 Alexander Graefenstein. See LICENSE for details.
